# Custom Memory Blocks

Раздел посвящен различным блокам памяти внутри PSXCPU.

:warning: The section needs to be re-checked and cleared of bitard-punk vocabulary.

Чип CPU сделан по технологии semi-custom IC. Это означает что большая часть логики генерируется автоматически, но часть специальных блоков сделана "руками".

По краям центрального процессора находится множество таких блоков, назначение большинства которых еще не выяснено.
Блоки пронумерованы в соответствии с частью процессора в которой они расположены для облегчения их идентификации. По мере понимания какую функцию они выполняют они будут переименованы.

![Cpu_units](/imgstore/custom/Cpu_units.jpg)

Всего на чипе расположено 16 блоков, которые можно разделить на 3 типа. Все блоки одного типа имеют одинаковую структуру, схожие блоки и отличаются только количеством столбцов и колонок.

- Constant Table Memory:
	- Unit-00: ScaleTableMatrix 8x8 (32 registers per 26 bits) used as 64 records per 13bits.
	- Unit-01: IDCT intermediate result (13 vertical, 16 horizontal, 16 x 13-bit words, separate IO)
	- Unit-02 (56 vertical, 8 horizontal)
	- Unit-03
	- Unit-04 (32 vertical, 16+32+16 horizontal)
	- Unit-05 (24 vertical, 16+32+16 horizontal)
	- Unit-20 (16 vertical, 16+32+16 horizontal)
- Dual port registers:
	- Unit-11 (mdec registers?) 32 32-bit dual port
	- Unit-21 (cpu registers?) 32 32-bit dual port
	- Unit-22 (GTE registers?) 16 16-bit dual port
	- Unit-23 (GTE registers?) 16 16-bit dual port
	- Unit-24 (GTE registers?) 16 16-bit dual port
	- Unit-25 (GTE registers?) 16 16-bit dual port
- SRAM:
	- Unit-10 (mdec output RGB macroblock(?) 768 bytes)(24x8 vertical, 32 horizontal)
	- Unit-26 (data cache 1024 bytes)(32x8 vertical, 32 horizontal)
	- Unit-30 (instruction cache 4096 bytes)(32x8 vertical, 128 horizontal)

## Constant Table Memory

В блоках этого типа хранятся таблицы с константами или временные результаты вычислений.

![Cpu_unit_type1](/imgstore/custom/Cpu_unit_type1.jpg)

Типовые элементы этих блоков одинаковые, отличаются только способом подключения друг к другу (и соответственно разводкой металла).

### Cell

![Unit00_cell](/imgstore/custom/Unit00_cell.jpg)

Обычная би-стабильная защёлка на базе двух инверторов и управляющие транзисторы:

- IE (input enable) : разрешает запись в защелку. Output Enable не предусмотрен.
- row: вместо Output Enable используется row select, который выбирает целый ряд ячеек для чтения/записи.
- in: входное значение
- out: выходное значение

Примечание: значение на защёлке хранится в инвертированной форме (так удобнее).

### 2-to-4 decoders

![Unit00_decoder1](/imgstore/custom/Unit00_decoder1.jpg)

В эту часть декодера поступают входные разряды индекса, которые затем комбинируются в разной последовательности в схемах ANDs, для окончательного выбора ряда.

### ANDs (вторая стадия декодирования)

![Unit00_decoder2](/imgstore/custom/Unit00_decoder2.jpg)

Совместно два этих этапа формируют декодер большей разрядности (например у Unit-00 получается декодер 5-в-32).

### IO tri-state buffers

![Unit00_tristate](/imgstore/custom/Unit00_tristate.jpg)

Обычные tri-state буферы, управляемые контрольными сигналами OE (output enable) и IE (input enable).

Если OE или IE равны 0, то входы/выходы "отключаются" (Z), иначе входы/выходы подключаются к выбранной ячейке для обмена данными.

### IO enable

![Unit00_io_enable](/imgstore/custom/Unit00_io_enable.jpg)

Младшие 4 разряда tri-state буферов имеют альтернативную топологию (разводку металла), которая добавляет туда схему усиления входных сигналов OE / IE.

Входные управляющие сигналы OE/IE приходят на 0й разряд буферов, при этом OE обычно подключен к питанию (OE=1, то есть выход всегда открыт).

### Unit-00 ScaleTableMatrix

![Unit00_overview](/imgstore/custom/Unit00_overview.jpg)

Организована в виде 32 рядов по 26 ячеек. При этом внешние схемы разбивают 26 разрядов на две 13-разрядные половинки, в результате значения матрицы Scale Table хранятся как 64 13-разрядных слов.

5-й бит индекса ряда не используется (подключен к земле), так как у нас адресуется только 32 ряда ячеек (биты индекса 0-4).

На SVN находится полная логическая схема, которая работает в симуляторе Logisim.

Дополнительным элементом этого юнита является разделение ячеек на верхнюю и нижнюю половину (по 16 рядов), с добавлением дополнительной логики выбора половины, на основе 5го разряда индекса:

![Unit00_gap](/imgstore/custom/Unit00_gap.jpg)

Схема комбинирует 5-й разряд и входной контрольный сигнал input enable, для "подключения" верхней или нижней половины. Output enable контроль однако не предусмотрен и контролируется только декодером (row select).

Output enable Unit-00 всегда включен (подключен к питанию), то есть выходы всегда нагружены последним записанным значением.

Контакты (**смотри внимательно входы/выходы чередуются**):

![Unit00_pads](/imgstore/custom/Unit00_pads.jpg)

### Unit-01: Промежуточный результат вычислений IDCT

![Unit01_overview](/imgstore/custom/Unit01_overview.jpg)

Блок состоит из типовых компонентов: ячейки, tri-state буферы и 2 декодера 4-в-16.

Схема IO enable стандартным образом основана на альтернативном роутинге первых 4х буферов (биты 0-3).

Особенности:

- Ячейки имеют разделенный ввод/вывод. То есть для входа может быть выбрана одна ячейка, а для выхода - другая. Это нужно для того чтобы организовать распределенное умножение IDCT в 2 прохода. Пока один проход использует один промежуточный результат, второй проход использует другой.
- Соответственно для этой цели вместо подачи одного провода "row" на каждую ячейку подается 2 провода: "row_in" и "row_out"
- Также вместо одного декодера используется 2: один для выбора входной ячейки, второй для выбора выходной.

Ячейка:

![Unit01_cell](/imgstore/custom/Unit01_cell.jpg)

Контакты (**опять будь внимателен, входы/выходы чередуются in/out -> out/in**)

![Unit01_pads](/imgstore/custom/Unit01_pads.jpg)

## Dual port registers

Позволяют одновременно записать в два разных регистра, а также выдать значение двух любых регистров на 2 разных выхода, за одно действие.

![Cpu_unit_type2](/imgstore/custom/Cpu_unit_type2.jpg)

### 16-разрядные dual port registers

![Unit24_overview](/imgstore/custom/Unit24_overview.jpg)

- Основную часть занимают ячейки, организованные в виде матрицы 16x16. Один ряд ячеек представляет собой 1 регистр. Нумерация разрядов идёт справа-налево для линий данных и слева-направо для линий индексации.
- Справа вверху находятся 8 декодеров 2-в-4. Они из 16 входов делают 32 выхода, причем входы декодируются по 2 близлежащих рязряда. Затем эти 32 выхода подаются на массив 4x16 операций AND, каждая из 16 линеек выдает по 4 выхода влево. Совместно эти схемы образуют декодер 4-в-16, для выбора ряда.
- Слева вверху находятся входы/выходы с регистров.
- Вверху по середине находится схема IO enable для буферов, чуть ниже находится страховочная схема Input enable для ячеек. Output enable для ячеек не предусмотрено, то ли забыли добавить, то ли забили на неё)))

### Cell

![Unit24_cell_tran](/imgstore/custom/Unit24_cell_tran.jpg)

В каждую ячейку приходит 4 провода сверху (1-4) и 4 сбоку (5-8). Всего таких ячеек 16 по вертикали и 16 по горизонтали.

![Unit24_cell](/imgstore/custom/Unit24_cell.jpg)

Особенность регистров в том, что у них селективный вход (2-на-1) и селективный выход (1-на-2), для быстрого копирования значений.

Когда рисовал схемы произошла небольшая путаница в нумерации. Поэтому вот человеческое обозначение входов/выходов, чтобы не запутаться:

- 1: Output 2
- 2: Output 1
- 3: Input 2
- 4: Input 1
- 5: Input 1 enable
- 6: Input 2 enable
- 7: Output 1 enable
- 8: Output 2 enable

От этих названий пляшем.

### IO Enable

Разводит по внутренностям блока усиленные сигналы input/output enable.

![Unit24_io_enable](/imgstore/custom/Unit24_io_enable.jpg)

У Unit22-25 OE1=OE2=1 (подсоединены к питанию), то есть используются оба выхода.

### Register IO buffers

Используются в основном для усиления выходного сигнала, а также в качестве tri-state буфера для включения/выключения обмена между определенными входами и выходами регистров.

На вход принимает 4 контрольных сигнала, приходящих со схемы IO Enable:

- IE1, IE2: input enable. Если IE=0, то соответствующий вход переходит в состояние tri-state (отключается).
- OE1, OE2: output enable. Если OE=0, то соответствующий выход переходит в состояние tri-state (отключается).

![Unit24_reg_inputs_outputs](/imgstore/custom/Unit24_reg_inputs_outputs.jpg)

### 2-to-4 decoders

![Unit24_decoder_2-to-4](/imgstore/custom/Unit24_decoder_2-to-4.jpg)

Часть декодера.

### ANDs

![Unit24_ands](/imgstore/custom/Unit24_ands.jpg)

Очередной этап декодирования индекса регистра, массив 4x16 операций AND.

На вход поступает 32 линии с декодеров 2-на-4, которые расположены выше. Эти линии насквозь пронизывают массив элементов AND и выборочно соединяются с входами AND.

На выходе каждой линейки AND - 4 выхода, 2 из которых идут сразу на ячейки, а ещё 2 поступают на схему Input Enable.

Схемы ANDs и 2-на-4 совместно составляют декодер ряда 4-на-16: 

![Unit24_decoder](/imgstore/custom/Unit24_decoder.jpg)

### Input enable

2 выхода со схем AND идут на эту схему, где производится дополнительная операция AND между входными шлангами и IE1/IE2.

Если IE1/IE2=0, то соотв. выход 5/6 = 0 и вход ячейки перекрывается.

![Unit24_input_enable](/imgstore/custom/Unit24_input_enable.jpg)

Здесь есть небольшая недоделка: в схеме присутствует контроль транзисторов 5/6 ячейки памяти (IE1/IE2), но нет контроля транзисторов 7/8 (которые открывают выходы). Хотя это не так нужно, потому что входы/выходы всё равно отключаются в схеме Register IO buffers. По сути эта схема Input enable тоже не нужна, но разработчики видимо перестраховались.

### Логическая схема

![Dualport16](/imgstore/custom/Dualport16.jpg)

Не уверен только в нумерации выходных разрядов. Скорее всего (по аналогии с другими юнитами) нумерация разрядов идёт справа-налево.
То есть там где на картинке написано Bit0 - на самом деле Bit31, картинку переделывать в лом.

## SRAM

Блоки данного типа представляют собой статическую память SRAM, использующуюся как кэш для различных данных.

![Cpu_unit_type3](/imgstore/custom/Cpu_unit_type3.jpg)

Кэш данных имеет на входе 18 управляющих линий (среди них где-то линии шины адреса), а также 32x2 линии Data bus.

Кэш инструкций имеет 17 управляющих линий (2 из них не используются) и 32x2 шину данных (инструкцию).

Особенность шин данных у кешей заключается в том их линии спаренные для каждого разряда (кружочками показаны места где линии соединяются в одну):

![DCache_data_lines](/imgstore/custom/DCache_data_lines.jpg)

![ICache_data_lines](/imgstore/custom/ICache_data_lines.jpg)

Одна линия работает на вход, другая на выход (шина данных двунаправленная). Такая организация возможно связана с тем, что перед реализацией схемы в силиконе она была проверена в симуляторе, в котором проще делать однонаправленные входы и выходы.

Функционально блоки состоят из:

- Декодер ряда (row decoder)
- Декодер столбца (column decoder)
- Логики управления
- Входные буферы адресных линий
- Буферы шины данных
- Массив ячеек памяти

### SRAM cell

Ячейка памяти представляет собой обычную CMOS SRAM-cell, на базе 6 транзисторов.

![Sram_cell](/imgstore/custom/Sram_cell.jpg)

![Sram_cell_trans](/imgstore/custom/Sram_cell_trans.jpg)

Элемент памяти - это Flip-flop, основанный на спаренных инверторах, входы которых подсоединены к column line через row line tri-state буфер.

Когда row = 0 ячейка находится в бистабильном состоянии и хранит заряд.

Когда row = 1 - весь ряд ячеек "открывается", но заряд меняет только та, у которой линия column НЕ имеет значение Z (НЕ разорвана).

Управлением доступа к ячейкам занимается специальный Row/Column декодер, который на базе входной шины адреса формирует линии row/column.
